## 前言

任务执行顺序（周而复始）：1.宏任务、2.微任务、3.浏览器渲染（重绘或重载，没有就相关任务就不执行）、继续步骤 123。
关联知识点：Event Loop（事件循环）、同步任务、异步任务、进程、线程、执行栈、堆、任务队列、浏览器等。

## 执行 JS 代码与任务分类

以浏览器环境内执行 JS 代码为例，运行时，主要涉及：JS 引擎线程、执行栈、事件触发线程、任务队列。

- JS 引擎线程：位于浏览器渲染进程中，用于解析与执行 JS 代码。
- 执行栈：由于 JS 引擎是单线程的，所以同一个时间只会处理一个任务，然而在处理一个任务时，会伴随着多个子任务，也就形成了一个栈结构。
- 事件触发线程：位于浏览器渲染进程中，负责管理事件，事件包括：DOM 事件、鼠标点击、AJAX、setTimeout 等。当事件完成后，将回调任务放入任务队列。
- 任务队列：存放浏览器相关事件完成后的回调任务，这些任务就是同步任务。

宏任务、微任务的执行顺序

1. 当执行栈为空时，JS 引擎会将最早进入任务队列中的宏任务放入执行栈内执行。
2. 执行栈内执行宏任务时，是按代码上下文逐行执行的，

- 当上下文中发现宏任务任务时，将同步任务交由事件触发线程管理，事件触发器线程将事件注册到 EventTable 中。等待该 Event 完成后，再将对应回调放入任务队列。
- 当上下文中发现微任务时，将微任务放入微任务队列。

3. 当执行栈内的任务（上下文）执行完毕后，也就是栈为空时，接下来，执行在该任务执行过程中，记录的微任务队列。
4. 当微任务队列执行完毕（清空）后，JS 引擎线程挂起，GUI 渲染线程进行页面渲染。
5. 页面渲染结束后，继续步骤 1。

> 上文中宏任务和微任务是两种任务类型，在 ECMAScript 中，宏任务被称为 task，微任务被称为 jobs。可以简单的理解为，宏任务是通过浏览器（宿主）提供的异步事件 API 创建的任务，由事件触发线程管理，当事件状态变更后，就会将对应回调加入事件任务队列，这些回调就是未来待执行的宏任务。然而，微任务也是“异步任务”，只是微任务放入的队列是 JS 引擎线程管理的微任务队列，这些事件的来源往往是 JS 原生语法，例如 Promise.then、MutationObserver 等。

结合以下代码示例，了解执行栈内，各任务的执行顺序。

```html
<html>
  <body>
    <script>
      console.log("start1");

      setTimeout(function fn1() {
        console.log("timeout1");
      }, 0);

      Promise.resolve()
        .then(function fn2() {
          console.log("then1");
        })
        .then(function fn3() {
          console.log("then2");
        });

      console.log("end1");
    </script>
  </body>
  ...
</html>
```

从 HTML 内的 `script` 标签说起：

1. 在浏览器 DOM 构建阶段，遇到了一个 `script` 标签，解析后放入事件任务队列中，并立即执行。
2. 此时，执行栈为空，JS 引擎线程将从事件任务队列中取一个最早进入的任务放入执行栈执行。
3. 对任务的上下文代码进行逐行执行。
4. 遇到 `console.log("start1")`，执行后，浏览器控制台输出文本 `start1` 后，下一行。
5. 遇到 `setTimeout()`，是个宏任务，将宏任务的事件和回调注册到 `Event Table` 中，下一行。
6. 遇到 `Promise.resolve().then().then()`，先执行 `Promise.resolve()`，返回了 Promise 类型的`实例1`， 执行 `实例1.then(fn2)` 时，将 `fn2` 放入微任务队列中，执行完毕，下一行。
7. 遇到 `console.log("end1")`，开始执行，浏览器控制台输出文本 `end1` 后，执行完毕。
8. 至此，同步任务上下文执行完毕，开始执行微任务队列（目前有 1 个 `fn2`）。
9. 将 `fn2` 放入执行栈中执行，执行完毕，浏览器控制台输出 `then1` 后，返回了 Promise 类型的`实例2`。
10. 继续执行 `实例2.then(fn3)` 后，将 `fn3` 放入微任务队列，完毕，继续清空微任务队列（目前有 `fn3`）。
11. 将 `fn3` 放入执行栈，执行完毕，浏览器控制台输出 `then2`，至此，微任务队列已空。
12. JS 引擎线程挂起，GUI 渲染线程进行页面渲染。
13. 页面渲染完毕后，执行栈为空，继续从任务队列中取任务，此时，任务队列中，有个任务 `fn1`。
14. `fn1` 执行完毕，输出文本 `timeout1`。

疑问与思考

- 步骤 6，当执行栈内执行表达式 `Promise.resolve().then().then()` 时，执行顺序是从上往下执行的。
  - `Promise.resolve()` 返回 promise 类型的 `实例1` 后出栈。
  - `Promise.resolve().then(fn1)` 将 fn1 放入微任务队列后出栈。
  - `Promise.resolve().then(fn1).then(fn2)` 等待 fn1 执行！而不是把 fn2 放入队列，因为加入的 fn1 内如果 throw Error 了呢。

> 补充说明：第一个 then 先进入微任务，完成第一个 then 的微任务后，返回新的 promise 类型的 `实例2`.then(fn2) 时，才把第二个 then 的放入微任务队列。 即执行第一个 then(fn1) 时，微任务队列中没有东西。当 fn1 执行完毕后，fn2 才放入了到微任务队列。然而继续清空微任务队列，执行了 fn2。

## JS 的事件循环机制（Event Loop）

宿主环境正是使用了事件循环实现了“多线程”任务执行。

虽然运行环境不同，但原理可以理解为无限循环任务（或称消息）队列，区别在于队列的分类与优先级。

- 浏览器厂商根据 html5 的规范。
- NodeJS 基于 libuv 实现。

```javascript
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

### 特点

#### 永不阻塞

JS 的事件循环是永不阻塞的，在执行代码上下文时，遇到能立即返回结果的语法，则等待执行结果，遇到异步 API，则挂起该行代码继续向下执行。通过这样的规则执行代码，理论上是不会阻塞代码执行的，但由于历史原因，一些 API 是会阻塞的，例如 alert、同步的 XHR。

#### 事件驱动的设计模式

从不阻塞的执行原理上看，异步 API 会使部分代码被挂起，等待执行。为了实现这个过程，JS 使用了事件驱动的设计模式，通过提供事件注册，维护事件状态与回调任务，当状态匹配后将对于对调任务放入任务队列中，等待被执行。

> 定时器事件。setTimeout 是常见的宏任务 API，由宿主提供。它的第二参数的描述是在设定的最小延迟时间，将任务放入任务队列。而非准确的时间。

#### 执行到底

当一个任务放入执行栈执行时，如果内部有函数需要运行，将会中断父函数执行，进入子函数执行，直到子函数返回结果退出到父函数的执行环境，使父函数继续向下执行。所以，当函数内出现较多嵌套的子函数时，就会导致栈内任务过多，会被浏览器提示“这个脚本运行时间过长”的对话框。

## 同步任务

## 异步任务

## 宏任务

简单理解：由宿主环境提供的基于事件的 API。
有哪些：UI render（视图渲染）、script 标签、AJAX、setTimeout、setInterval、IO、requestAnimationFrame、fetch……

> 目前常见的宿主环境：浏览器、Node

## 微任务

简单理解：由标准语言提供的基于事件的 API.
执行顺序：在最近一次宏任务执行完毕后执行。
分类：callback、callable、promiseFullfil、promiseReject。
有哪些：Promise.then、Object.observer（废弃）、Mutation.observer、process.nextTick……

## 参考

- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop
- https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly
- http://latentflip.com/loupe/
- https://www.jsv9000.app/
- https://segmentfault.com/a/1190000006811224

## 拓展知识

### 内存分配

内存存放数据，一般来说，分为两种内存空间，分别是栈（stack）与堆（heap）。

heap

- 是没有结构的，可以任意存放。用于复杂数据类型（对象）。
- 分配内存时，理论上，没有大小限制，不够用就继续分配。
- 每个进程分配一个 heap，所以 heap 在多个线程间是公用的。

stack

- 是有结构的，按照次序存放每个区块。主要存放基本类型的**变量和对象的引用**。
- 创建时，长度固定，超过大小是，就会 stack overflow 错误。
- 每个线程分配一个 stack。
